#!/usr/bin/env perl
#
# Copyright 2012-2015 Per Carlson
#
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl 5.14. For more details,
# see the full text of the licenses in the directory LICENSES.
#

use warnings;
use strict;
use feature ':5.10';

no if $] >= 5.017011, warnings => 'experimental::smartmatch';

use FindBin;
use lib "$FindBin::Bin/../lib/";
use lib "$FindBin::Bin/../lib/perl5";
use Getopt::Long '2.32';    # enables auto_version
use Pod::Usage;
use POSIX qw{ strftime };
use Text::Table;
use IO::Prompt;
use Algorithm::Diff;

use Netaudit::Db;
use Netaudit::Constants;
use Netaudit::Config;

# set version for getopt auto_version
our $VERSION = $Netaudit::Constants::VERSION;

# A hostname regexp
my $HOST_RE = qr/ [a-z] [-.a-z0-9]+ /ix;

# AoH of tables and their options
#
# TODO: this should come from the database
#
my @tables = ({
    name    => 'route_summary',
    descr   => 'Global routing summary',
    columns => [qw{ AFI Connected Static Local ISIS BGP }],
    order   => [qw{ afi }],
  },

  {
    name    => 'isis_neighbour',
    descr   => 'IS-IS neighbours',
    columns => [qw{ Neighbour Interface State }],
    order   => [qw{ interface }],
  },

  {
    name    => 'isis_topology',
    descr   => 'IS-IS topology',
    columns => [qw{ Host AFI NextHop Metric }],
    order   => [qw{ host afi }],
  },

  {
    name    => 'bgp',
    descr   => 'BGP peerings',
    columns => [qw{ Peer AFI VRF ASN Prefixes }],
    order   => [qw{ peer afi vrf }],
  },

  {
    name    => 'interface',
    descr   => "Interfaces with status and properties",
    columns => [qw{ Descr AdminStatus OperStatus IPv6Status MTU Speed }],
    order   => [qw{ descr }],
  },

  {
    name    => 'vrf',
    descr   => "VRF's and interfaces",
    columns => [qw{ VRF Active Associated }],
    order   => [qw{ vrf }],
  },

  {
    name    => 'pwe3',
    descr   => 'PWE3 circuits',
    columns => [qw{ Peer Interface VCid Status }],
    order   => [qw{ peer }],
  },
);

# options
my %opts = (
  colors => -t STDIN && -t STDOUT,    # no colors if not interactive
  configfile => '',                   # make sure it exists
);

Getopt::Long::Configure("auto_version");
#<<<
GetOptions(
  \%opts,
  'colors|C!',        # use colors in output
  'configfile|c=s',
  'diff|d:s',         # differential reporting from two runs
  'full:0',           # full reporting of one run
  'help|?',
  'hosts!',           # lists which runs each host is in
  'isis:0',           # check if isis v4 and v6 have same topology
  'list:99999',       # list runs
  'man',
  'purge=s',          # purge runs
  'runs!',            # lists which hosts in each run
) or pod2usage(2);
#<<<
pod2usage(1) if $opts{help};
pod2usage(-exitval => 2, -verbose => 2) if $opts{man};

my $cfg = eval { Netaudit::Config->new(filename => $opts{configfile}) };
die $@ if $@;

my $db = eval { Netaudit::Db->new(database => $cfg->database) };
die $@ if $@;

# try to load our recommended modules
# and check if the minimum version requirement
# are met
eval {
  require Term::ANSIColor;
  Term::ANSIColor->import();
  die unless $Term::ANSIColor::VERSION ge '2.01';
} or $opts{colors} = 0;

eval {
  require Text::Aligner;
  Text::Aligner->import();
  die unless $Text::Aligner::VERSION ge '0.06';
} or $opts{colors} = 0;

# Check which mode we are in
if (exists $opts{list}) {
  listruns($opts{list});
}

elsif (exists $opts{hosts}) {
  hostruns();
}

elsif (exists $opts{runs}) {
  runhosts();
}

elsif (exists $opts{purge}) {
  purgeruns(split(/-/, $opts{purge}));
}

elsif (exists $opts{isis}) {
  isisreport($opts{isis});
}

elsif (exists $opts{full}) {
  fullreport($opts{full}, shift @ARGV);
}

elsif (exists $opts{diff}) {
  diffreport($opts{diff}, shift @ARGV);
}

# if we end up here no operational mode is selected
else {
  # running a diff over the last runs is the default
  diffreport('', shift @ARGV);
}

exit;

# Modes

sub hostruns {
  # get the list of hostnames
  my $stmt = q/
    SELECT DISTINCT hostname
    FROM route_summary
  /;
  my @hosts = $db->select_column($stmt) or die "No hosts in database.\n";

  $stmt = q/
    SELECT DISTINCT run
    FROM route_summary
    WHERE hostname = ?
  /;
  # loop over the hosts picking up the runs
  foreach my $host (@hosts) {
    my @runs = $db->select_column($stmt, $host);
    say "Host: $host";
    say "Runs: ", join(", ", @runs);
    say '';
  }
}

sub runhosts {
  # get the list of runs
  my $stmt = q/
    SELECT run
    FROM runs
  /;
  my @runs = $db->select_column($stmt) or die "No hosts in database.\n";

  $stmt = q/
    SELECT DISTINCT hostname
    FROM route_summary
    WHERE run = ?
    ORDER BY hostname ASC
  /;
  # loop over the runs picking up the hosts
  foreach my $run (@runs) {
    my (undef, $epoch) = _getrun($run);
    printf "Run: %s (%s)\n", $run, _to_date($epoch);
    say "Hosts: ", join(", ", _gethosts($run));
    say '';
  }
}

sub fullreport {
  my ($run_arg, $hostname_arg) = @_;

  my $hostname;
  my $have_hostname_arg = defined $hostname_arg;
  if ($have_hostname_arg) {
    $hostname = $hostname_arg . '%';
  }
  else {
    $hostname = '%';
  }

  my ($run, $epoch) = _getrun($run_arg);
  unless ($run) {
    if ($run_arg == 0) {
      die "There are no runs in the database\n";
    }
    else {
      die "Run '$run_arg' do not exist. Use --list to view available runs.\n";
    }
  }

  # which hosts did we collect data from in the run
  my @hosts = _gethosts($run);

  # do @hosts contain our host?
  if ($have_hostname_arg) {
    die "'$hostname_arg' doesn't exist in run $run\n"
      if (scalar grep {m{ ^ $hostname_arg }xms} @hosts) == 0;
  }

  say "Full report of the audit run at: ". _to_date($epoch);
  say '';

  foreach my $href (@tables) {
    # Add 'Hostname' to columns and order
    my @columns = ( 'Hostname', @{$href->{columns}} );
    my @order   = ( 'hostname', @{$href->{order}} );

    my $table = Text::Table->new(_create_colspec(@columns));

    my $sql_cols  = _sql_select_cols(@columns);
    my $sql_order = join(',', @order);
    my $stmt = qq/
      SELECT $sql_cols FROM $href->{name}
      WHERE
        run = ?
      AND
        hostname LIKE ?
      ORDER BY $sql_order
    /;

    my $aref = $db->select_aref($stmt, $run, $hostname);

    foreach my $rref (@{$aref}) {
      $table->add(@{$rref});
    }
    say "$href->{descr}:";
    say "=" x length("$href->{descr}:");
    print $table->title();
    print $table->rule('-', '+');
    print $table->body();
    say '';
  }

  return;
}

sub diffreport {
  my ($diff_arg, $host_arg) = @_;
  my ($from, $to, $from_host, $to_host);

  # Submode 2: two hostnames, and one or two runs
  if ($diff_arg =~ /^ ($HOST_RE) , (\d+) , ($HOST_RE) (?: , (\d+))? $/x) {
    my ($f, $t);
    ($from_host, $f, $to_host, $t) = ($1, $2, $3, $4);

    # get from run
    $from = _getrun($f);

    # if $to is defined, use it. an empty $to mean $from
    $to = defined $t ? _getrun($t) : $from;

    _die_with_no_such_run($f) unless $from;
    _die_with_no_such_run($t) unless $to;

    printf "Comparing the results from %s (run %d) and %s (run %d)\n",
      $from_host, $from, $to_host, $to;
    _print_run_header($from);
    _print_run_header($to) if $from != $to;
    say '';

    _print_compare_help();

    # Add wildcards to hostnames (unless already set)
    $from_host .= '%' unless $from_host =~ /%/;
    $to_host   .= '%' unless $to_host   =~ /%/;

    foreach my $table (@tables) {
      my $old = _get_dbtable($table, $from, $from_host);
      my $new = _get_dbtable($table, $to,   $to_host);
      _show_diff($old, $new, $table);
    }

    return;
  }

  # grab the unmodified host
  my $have_host_arg = defined $host_arg;
  if ($have_host_arg) {
    $from_host = $host_arg . '%';
  }
  else {
    $from_host = '%';
  }

  # Submode 1 (diff over same host), with default arguments
  if ($diff_arg eq '' || $diff_arg eq "0") {
    # get the two last runs
    ($to, undef, $from, undef) = _getrun(-1, 2, $from_host);
    die "Can't find two runs for '$host_arg'\n" unless ($to && $from);

    # No difference between from and to_host
    $to_host = $from_host;
  }

  # Submode 1 (diff over same host), with arguments
  elsif ($diff_arg =~ /^ (\d+) (?: [-,] (\d+))? $/x) {
    my ($f, $t) = ($1, $2);
    # get from run
    $from = _getrun($f);

    # if $to is defined, use it. an empty $to mean the "last run"
    $to = defined $t ? _getrun($t) : _getrun(0);

    _die_with_no_such_run($f) unless $from;
    _die_with_no_such_run($t) unless $to;

    # No difference between from and to_host
    $to_host = $from_host;
  }

  else {
    die "Illegal --diff argument: $diff_arg\n";
  }

  # which hosts did we collect data from in the runs
  my @from_hosts = _gethosts($from);
  my @to_hosts   = _gethosts($to);

  # if a host is given, check that the host
  # is unique in both @from_hosts and @to_hosts
  # also out that host in the list of @hosts
  # we are looking for
  my @hosts;
  if ($have_host_arg) {
    @hosts = grep { /^$host_arg/ } @from_hosts;
    die "'$host_arg' isn't unique in run $from\n" if @hosts > 1;

    @hosts = grep { /^$host_arg/ } @to_hosts;
    die "'$host_arg' isn't unique in run $to\n" if @hosts > 1;
  }

  # if no host is given, run the diff over the hosts which
  # are in both runs
  else {
    # calculate the intersection and symmetric difference
    # of the hosts, i.e. the hosts present in both runs, and
    # those in only one run
    # code from receipe 4.8 in perl cookbook
    my @isect_hosts = ();
    my @diff_hosts  = ();
    my %count;
    foreach my $e (@from_hosts, @to_hosts) { $count{$e}++ }
    foreach my $e (keys %count) {
      push @{$count{$e} == 2 ? \@isect_hosts : \@diff_hosts}, $e;
    }

    if (@diff_hosts) {
      say "The hosts in the runs do not overlap completly. Only comparing";
      say "hosts audited in both runs. Those are:";
      say " - $_" for @isect_hosts;
      say '';
    }

    # store the isect_hosts in the list of hosts to look for
    @hosts = @isect_hosts;
  }

  say "Comparing the results from the audit runs";
  _print_run_header($from);
  _print_run_header($to);

  foreach my $table (@tables) {
    my ($old, $new);
    foreach my $host (@hosts) {
      my $o = _get_dbtable($table, $from, $host);
      my $n = _get_dbtable($table, $to,   $host);

      # Add hostname as first column in all rows
      unshift(@{$_}, $host) for @$o;
      unshift(@{$_}, $host) for @$n;

      push @$old, @$o;
      push @$new, @$n;
    }

    _show_diff($old, $new, $table, 'include_hosts');
  }

  say '';
}

sub purgeruns {
  my ($start, $stop) = @_;

  # if any of the ranges are undef, use same value as other end
  # (one run is selected)
  $start = $stop  unless defined $start;
  $stop  = $start unless defined $stop;

  return unless prompt("Purging runs from $start to $stop? [y/n] ", '-1y');

  my $rows
    = $db->dostmt("DELETE FROM runs WHERE run BETWEEN ? AND ?", $start, $stop);
  printf "Deleted %d runs from database\n", $rows;

  return;
}

sub listruns {
  my ($count) = @_;

  my @runs = _getrun(-1, $count) or die "Didn't find any matching runs\n";

  printf "%3s | %s\n", "run", "date/time";
  while (my ($r, $e) = splice(@runs, 0, 2)) {
    printf "%3d | %s\n", $r, _to_date($e);
  }
  return;
}

sub isisreport {
  my ($run) = @_;

  my $epoch;
  ($run, $epoch) = _getrun($run)
    or die "Run $run do not exist. Use --list to view available runs.\n";

  say "ISIS topology audit of the run at: ". _to_date($epoch);
  say '';

  my $v4stmt = q/
    SELECT hostname, host, interface, metric
    FROM isis_topology
    WHERE
      afi = 'ipv4'
    AND
      run = ?
  /;

  my $v4 = eval { $db->select_aref($v4stmt, $run) };
  die "SQL statement failed: $@\n" if $@;
  die "No data found\n" unless $v4;

  my $v6stmt = q/
    SELECT metric
    FROM isis_topology
    WHERE
      afi = 'ipv6'
    AND
      hostname = ?
    AND
      host = ?
    AND
      interface = ?
    AND
      run = ?
  /;

  my @colspec = (
    \'| ', map { ($_, \' | ') } qw{ Hostname Host Interface IPv4 },
    "IPv6", \' |'
  );
  my $table = Text::Table->new(@colspec);

  foreach my $row (@{$v4}) {
    my ($hostname, $host, $interface, $v4metric) = @{$row};
    my ($v6metric)
      = eval { $db->select_row($v6stmt, $hostname, $host, $interface, $run); };
    $v6metric ||= "-";

    if ($v4metric ne $v6metric) {
      $table->add($hostname, $host, $interface, $v4metric, $v6metric);
    }
  }

  if ($table->body_height > 0) {
    print $table->title;
    print $table->rule('-', '+');
    print $table->body;
  }
  else {
    say "Gratulations! No inconsistencies in the topologies";
  }
  say '';

  return;
}

sub numerical {
  my @vals = @_;

  my $ok = 1;
  foreach (@vals) {
    return 0 if !defined $_;    # an undef is never numerical
    $ok &&= $_ =~ /^ \s* -* \d+ \s* $/xms;
  }
  return $ok;
}

#---

sub formattuple {
  my ($old, $new) = @_;

  # if any of old or new is numerical, calculate the difference
  if (numerical($old) || numerical($new)) {
    # make sure both is numerical
    $old = 0 if !numerical($old);
    $new = 0 if !numerical($new);
    my $diff  = $new - $old;
    my $color = "reset";
    $color = "green" if $diff > 0;
    $color = "red"   if $diff < 0;
    my $str = sprintf "[% +d]", $diff;
    return sprintf "%6d %s", $new, colorize($str, $color);
  }

  # if both old and new are empty, return empty string
  elsif (!$old && !$new) {
    return "";
  }

  # print both strings
  else {
    my ($oldcolor, $newcolor);
    $oldcolor = $newcolor = "reset";
    if ($old =~ /down/i && $new =~ /up/i) {
      $oldcolor = "red";
      $newcolor = "green";
    }
    if ($old =~ /up/i && $new =~ /down/i) {
      $oldcolor = "green";
      $newcolor = "red";
    }
    return sprintf "%s [%s]", colorize($new, $newcolor),
      colorize($old, $oldcolor);
  }
}

#---

sub formatitem {
  my $item = shift;

  if (numerical($item)) {
    return sprintf("%6d", $item);
  }
  else {
    return sprintf("%6s", $item // '');
  }
}

#---

sub formatlist {
  return map { formatitem($_) } @_;
}

#---

sub colorize {
  my ($str, $color) = @_;

  return $opts{colors} ? colored($str, $color) : $str;
}

# Helper subs

sub _create_colspec {
  my @colspec = (\'| ', map { ($_, \' | ') } @_);
  # replace the last col attribute with one without a trailing space
  $colspec[-1] = \' |';

  return @colspec;
}

sub _die_with_no_such_run {
  my $run = shift;
  die "Run $run do not exist\n";
}

sub _get_dbtable {
  my ($table, $run, $hostname) = @_;

  my $sql_cols  = _sql_select_cols(@{$table->{columns}});
  my $sql_order = join(',', @{$table->{order}});
  my $stmt = qq/
    SELECT $sql_cols FROM $table->{name}
    WHERE
      run = ?
    AND
      hostname LIKE ?
    ORDER BY $sql_order
  /;

  my $result = $db->select_aref($stmt, $run, $hostname)
    or die "Couldn't get data from the run $run\n";
  return $result;
}

sub _gethosts {
  my ($run) = @_;

  my $stmt = q/
    SELECT DISTINCT hostname
    FROM route_summary
    WHERE run = ?
  /;
  my @hosts = $db->select_column($stmt, $run);

  return @hosts;
}

sub _getrun {
  my ($run, $count, $hostname) = @_;
  # run ==  0 => get id of last run
  # run == -1 => get id of $count last runs
  # else => check if run exist

  # safe defaults
  $count //= 999999;
  $hostname //= '%';
  my $quoted_host = $db->quote($hostname);

  my ($stmt, $arg);

  given ($run) {
    when ($_ == 0) {
      $stmt = q/
        SELECT run, epoch
        FROM runs
        ORDER BY run DESC
        LIMIT 1
      /;
    }

    when ($_ == -1) {
      $stmt = qq/
        SELECT DISTINCT runs.run, epoch
        FROM runs
        JOIN route_summary
        WHERE
          route_summary.run = runs.run
        AND
          route_summary.hostname LIKE $quoted_host
        ORDER BY runs.run DESC
        LIMIT $count
      /;
    }

    default {
      $stmt = qq/
        SELECT run, epoch
        FROM runs
        WHERE run = $run
      /;
    }
  }

  my $aref = eval { $db->select_aref($stmt) };
  die $@ if $@;

  my @result;
  if ($aref) {
    foreach my $rref (@{$aref}) {
      push(@result, @{$rref});
    }
  }

  return wantarray ? @result : $result[0];
}

sub _print_run_header {
  my $run = shift;
  my (undef, $epoch) = _getrun($run);
  printf "Run %2d @ %s\n", $run, _to_date($epoch);
}

sub _show_diff {
  my ($old, $new, $table, $include_hostname) = @_;
  $include_hostname //= 0;

  my $columns = $table->{columns};
  my $order   = $table->{order};
  if ($include_hostname) {
    unshift @$columns, 'Hostname';
    unshift @$order,   'hostname';
  }

  my $result = Text::Table->new(_create_colspec(@$columns));

  # when running the diff, we can't compare the rows with data directly.
  # instead, create a stringified representation of each row, and
  # compare that one.
  #
  # fullkey is a string covering all columns, and is used as the key when
  # running diff over the old and new arrays.
  #
  # shortkey is a string covering the columns needed to identify one data
  # point. if two such strings are identical, the rest of the columns
  # are variable data that should be compared.

  foreach my $aref (@{$old}, @{$new}) {
    my $fullkey  = join(";", map { $_ || "" } @{$aref});
    my $shortkey = join(";", map { $_ || "" } @{$aref}[0..$#{$order}]);
    push(@{$aref}, $shortkey, $fullkey);
  }

  # run a diff of the two AoA's using the fullkey (last element in each array)
  # as the key
  my $diff = Algorithm::Diff::diff($old, $new, sub { $_[0][-1] });

  # flatten the diffs into a list of changes. we are not interested
  # in how to transform old -> new, only the changes.
  my %HoA;
  foreach my $hunk (@{$diff}) {
    foreach my $element (@{$hunk}) {
      my $op   = @{$element}[0];
      my $item = @{$element}[2];
      # copy "shortkey" to key and drop "fullkey"
      my ($key, undef) = splice(@{$item}, -2);
      push(@{$HoA{$key}}, [$op, $item]);
    }
  }

  foreach my $k (sort keys %HoA) {
    # if there is only one element, add it to result
    if (scalar @{$HoA{$k}} == 1) {
      my ($op, $element) = splice @{${$HoA{$k}}[0]}, -2;
      if ($op eq '+') {
        $result->add(map { formatitem($_ || "") } @{$element});
      }
      else {
        $result->add(map { formatitem($_ ? "[$_]" : "") } @{$element});
      }
    }
    else {
      my ($oldop, $oldel) = splice @{${$HoA{$k}}[0]}, -2;
      my ($newop, $newel) = splice @{${$HoA{$k}}[1]}, -2;

      # op1/element1 must be the 'old' pair (ie. not added/+'ed)
      if ($oldop eq '+') {
        my $tmp;
        $tmp   = $oldop;
        $oldop = $newop;
        $newop = $tmp;
        $tmp   = $oldel;
        $oldel = $newel;
        $newel = $tmp;
      }

      my @a;
      # loop over the new elements and store the diff with old
      foreach my $i (0 .. scalar @{$newel}) {
        my $e1 = $$oldel[$i] || "";
        my $e2 = $$newel[$i] || "";

        # if no change, just store the element
        if ($e1 eq $e2) {
          push(@a, formatitem($e2));
        }
        # something changed
        else {
          push(@a, formattuple($e1, $e2));
        }
      }
      $result->add(@a);
    }
  }

  print "$table->{descr}\n";
  print "=" x length($table->{descr}) . "\n";

  if ($result->body_height > 0) {
    print $result->title;
    print $result->rule('-', '+');
    print $result->body;
  }
  else {
    print "No changes\n";
  }
  print "\n";

  return;
}

sub _strip_first_col {
  my $aaref = shift;
  shift @{$aaref->[$_]} for (0 .. $#{$aaref});
  return $aaref;
}

sub _sql_select_cols {
  return join(',', map { lc } @_);
}

sub _to_date {
  my $epoch = shift;
  return strftime("%F %R%z", localtime($epoch));
}

sub _print_compare_help {
  print << 'EOF'
Note, this mode is particulary hard to interpret ths result of.

Let's say we've got the following result (the row number is
added for reference) after running the command 'netreport -d A,1,B,2'

| Row | Host | AFI    | NextHop | Metric          |
+-----+------+--------+---------+-----------------+
| 1   | [B]  | [ipv4] | [E]     | [1000]          |
| 2   | A    | ipv4   | E       |   3105          |
| 3   | C    | ipv4   | D [B]   |   1005 [-3095]  |

Row 1 has got ALL values within brackets ([]).
=> This row was present in 'A run 1' but is missing from 'B run 2'.

Row 2 has NO values in brackets.
=> This row wasn't present in 'A run 1' but is in 'B run 2'.

Row 3 has SOME values in brackets.
=> The values NOT in brackets has NOT changed between 'A run 1' and 'B run 2'.
=> The values WITH brackets has changed, and the value IN the brackets
   is the one in 'A run 1', and the value WITHOUT brackets is in 'B run 2'.

   Here: The nexthop to C has changed from B to D, and the metric is
   lowered from 4100 to 1005 between 'A run 1' and 'B run 2'.

Rember: Values in brackets are the "old" (first) host/run, and
values without brackets are the "new" (second) host/run.


EOF
}

__DATA__

=pod

=head1 NAME

netreport -- Prints a report of the data captured by L<netaudit(1)>

=head1 SYNOPSIS

netreport  [--help | --man] [options] [--] [hostname]

 --help   Show brief help text
 --man    Show full man page

=head1 DESCRIPTION

Print a report of the collected data from one or more L<netaudit(1)> runs.
The default is to run in C<--diff> mode, either over the devices in last two
runs (if no C<hostname> on command-line), or the last two runs where there
is data for C<hostname>.

=head1 OPTIONS

=over

=item B<-C> | B<--colors>

Enable colorized output.
To disable colors use B<--no-colors>.
This is used when running in diff mode.
Default is ON unless when run in a non-interactively enviroment
(such from cron) where it's OFF.

=item B<-c> F<filename> | B<--configfile>=F<filename>

The location of the configuration file to use.
A config file is searched for in the following order:

=over 2

=item * B<--configfile> argument

=item * F<netaudit.conf>

=item * F<~/.netaudit>

=item * F</usr/local/etc/netaudit.conf>

=item * F</etc/netaudit.conf>

=back

Note that the B<first> found config file is used, there is B<NO>
hierarchy of config files.

The format of the config file is specified in L<netaudit(1)>

=item B<hostname>

Run the report only for I<hostname>.
There is no need to write the I<hostname> as a FQDN, as long as
the part given is unique.
If L<netreport> gets confused by the I<hostname> put a '--' as
an argument before the B<hostname> on the command line.

=back

=head1 MODES OF OPERATION

=head2 B<Diff mode>

The I<diff mode> can be run in two different ways (or sub-modes):
report the difference for a I<specific> host between two runs,
and comparing two I<different> hosts at same or different runs.

If the tool is used for checking the state of a host before and after
a certain event (e.g. a software upgrade) the first sub-mode is used.

The use case for the second sub-mode is checking states if for example
all services are moved from one host to another.

=over

=item B<-d> [RUN[,RUN]] | B<--diff>[=RUN[,RUN]]

This is the first sub-mode.

Select which runs the report should be be based on.
This is the default mode.
Default (if no RUN) is to show the difference between the
two last runs.

If a I<hostname> is specified on the command line, the B<diff> will be
run over the two last runs where I<hostname> has some collected data.
Otherwise the B<diff> is done for the hosts in both last two runs.

Note: If you would run a diff over the last runs for a specific host,
you must use '--' to tell that the hostname isn't a parameter to the B<-d> like:

    netaudit -d -- foo

=item B<-d> hostname1,RUN1,hostname2[,RUN2] | B<--diff>=hostname1,RUN1,hostname2[,RUN2]

This is the second sub-mode.

Report the the difference between B<hostname1> at B<RUN1>
and B<hostname2> at B<RUN1> (or B<RUN2> if specified).

=back

=head2 B<Full report>

=over

=item B<-f> [RUN] | B<--full>[=RUN]

Show a full report, i.e. all collected data, from a single run.
Default (when no RUN) is to print the report from the last run.

Accepts a I<hostname> as parameter for pruning the report.

=back

=head2 B<ISIS>

=over

=item B<-i> [RUN] | B<--isis>[=RUN]

Compare the ISIS topologies for IPv4 and IPv6, and report any
differences in outgoing interfaces and/or metrics.
Default (when no RUN) is to print the report from the last run.

=back

=head2 B<Queries>

=over

=item B<--hosts>

For each host in the database print the runs which there
are stored data in the database.

=item B<--list>[=RUN]

Lists the RUN last runs stored in the database. Without a RUN all runs
are printed.

=item B<--runs>

For each run in the database print the hosts which there
are stored data in the database.

=back

=head2 B<Delete runs from database>

=over

=item B<-p> RANGE | B<--purge>=RANGE

Remove the runs from the database matching RANGE

=back

=head1 NUMERICAL ARGUMENTS

=head2 RUN

Each RUN is a single number, and may consist of either:

     N    Select the N'th run
     0    Select the last run

=head2 RANGE

Each RANGE is made up of a start and stop run.
A RANGE is one of:

     N    Select the runs from N'th to last run
   N-M    Select the runs from N'th to M'th (included)

When purging runs the most useful RANGE is I<N-M>. If you would like to remove
the oldest data you can use I<0> instead of I<N>, i.e the option will be
I<--purge=0-M>

=head1 AUTHOR

Per Carlson L<< <pelle@hemmop.com> >>

=head1 COPYRIGHT AND LICENSE

Copyright 2012-2015 Per Carlson.

This application is free software; you can redistribute it and/or modify it
under the same terms as Perl 5.14 itself.

=head1 SEE ALSO

L<netaudit(1)>

=cut


